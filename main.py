import tkinter as tk
from tkinter import filedialog, messagebox
import pefile
import numpy as np
import pickle as pkl

# >>> Suspicious functions count -> text file with API calls usually used by malware <<<
sus_examples = set()
with open('suspicious_functions_examples.txt') as i:
    sus_examples = {f.strip() for f in i}

# >>> loading the model that I have created in the "model.py" script <<<
file = open('model.pkl', 'rb')
model = pkl.load(file)

# >>> Initial window, allows user to Run or Choose File <<<
root = tk.Tk()
root.title('Malware Prediction')


def open():
    # >>> Ensures the filepath variable is global, can be used by the rest of the program <<<
    global filepath

    # >>> Assigning chosen file to variable <<<
    filepath = filedialog.askopenfilename()
    path_label.config(text=filepath)


def predict_file():
    # >>> Extracting features through pefile <<<
    pe = pefile.PE(filepath)

    sus_functions = 0
    num_packers = 0

    features = {
        # >>> DOS Headers <<<,
        'e_magic': pe.DOS_HEADER.e_magic,
        'e_cblp': pe.DOS_HEADER.e_cblp,
        'e_cp': pe.DOS_HEADER.e_cp,
        'e_crlc': pe.DOS_HEADER.e_crlc,
        'e_cparhdr': pe.DOS_HEADER.e_cparhdr,
        'e_minalloc': pe.DOS_HEADER.e_minalloc,
        'e_maxalloc': pe.DOS_HEADER.e_maxalloc,
        'e_ss': pe.DOS_HEADER.e_ss,
        'e_sp': pe.DOS_HEADER.e_sp,
        'e_csum': pe.DOS_HEADER.e_csum,
        'e_ip': pe.DOS_HEADER.e_ip,
        'e_cs': pe.DOS_HEADER.e_cs,
        'e_lfarlc': pe.DOS_HEADER.e_lfarlc,
        'e_ovno': pe.DOS_HEADER.e_ovno,
        'e_oemid': pe.DOS_HEADER.e_oemid,
        'e_oeminfo': pe.DOS_HEADER.e_oeminfo,
        'e_lfanew': pe.DOS_HEADER.e_lfanew,
        # >>> File Headers <<<
        'Machine': pe.FILE_HEADER.Machine,
        'NumberOfSections': pe.FILE_HEADER.NumberOfSections,
        'TimeDateStamp': pe.FILE_HEADER.TimeDateStamp,
        'PointerToSymbolTable': pe.FILE_HEADER.PointerToSymbolTable,
        'NumberOfSymbols': pe.FILE_HEADER.NumberOfSymbols,
        'SizeOfOptionalHeader': pe.FILE_HEADER.SizeOfOptionalHeader,
        'Characteristics': pe.FILE_HEADER.Characteristics,
        # >>> Optional Headers <<<
        'Magic': pe.OPTIONAL_HEADER.Magic,
        'MajorLinkerVersion': pe.OPTIONAL_HEADER.MajorLinkerVersion,
        'MinorLinkerVersion': pe.OPTIONAL_HEADER.MinorLinkerVersion,
        'SizeOfCode': pe.OPTIONAL_HEADER.SizeOfCode,
        'SizeOfInitializedData': pe.OPTIONAL_HEADER.SizeOfInitializedData,
        'SizeOfUninitializedData': pe.OPTIONAL_HEADER.SizeOfUninitializedData,
        'AddressOfEntryPoint': pe.OPTIONAL_HEADER.AddressOfEntryPoint,
        'BaseOfCode': pe.OPTIONAL_HEADER.BaseOfCode,
        'ImageBase': pe.OPTIONAL_HEADER.ImageBase,
        'SectionAlignment': pe.OPTIONAL_HEADER.SectionAlignment,
        'FileAlignment': pe.OPTIONAL_HEADER.FileAlignment,
        'MajorOperatingSystemVersion': pe.OPTIONAL_HEADER.MajorOperatingSystemVersion,
        'MinorOperatingSystemVersion': pe.OPTIONAL_HEADER.MinorOperatingSystemVersion,
        'MajorImageVersion': pe.OPTIONAL_HEADER.MajorImageVersion,
        'MinorImageVersion': pe.OPTIONAL_HEADER.MinorImageVersion,
        'MajorSubsystemVersion': pe.OPTIONAL_HEADER.MajorSubsystemVersion,
        'MinorSubsystemVersion': pe.OPTIONAL_HEADER.MinorSubsystemVersion,
        'SizeOfHeaders': pe.OPTIONAL_HEADER.SizeOfHeaders,
        'CheckSum': pe.OPTIONAL_HEADER.CheckSum,
        'SizeOfImage': pe.OPTIONAL_HEADER.SizeOfImage,
        'Subsystem': pe.OPTIONAL_HEADER.Subsystem,
        'DllCharacteristics': pe.OPTIONAL_HEADER.DllCharacteristics,
        'SizeOfStackReserve': pe.OPTIONAL_HEADER.SizeOfStackReserve,
        'SizeOfStackCommit': pe.OPTIONAL_HEADER.SizeOfStackCommit,
        'SizeOfHeapReserve': pe.OPTIONAL_HEADER.SizeOfHeapReserve,
        'SizeOfHeapCommit': pe.OPTIONAL_HEADER.SizeOfHeapCommit,
        'LoaderFlags': pe.OPTIONAL_HEADER.LoaderFlags,
        'NumberOfRvaAndSizes': pe.OPTIONAL_HEADER.NumberOfRvaAndSizes,
    }

    # >>> Calculations for features which do not fit under normally <<<
    entropy = map(lambda x: x.get_entropy(), pe.sections)
    raw_size = map(lambda x: x.SizeOfRawData, pe.sections)
    v_size = map(lambda x: x.Misc_VirtualSize, pe.sections)
    phys = map(lambda x: x.Misc_PhysicalAddress, pe.sections)
    v_address = map(lambda x: x.VirtualAddress, pe.sections)
    pointer_data = map(lambda x: x.PointerToRawData, pe.sections)
    characteristics = map(lambda x: x.Characteristics, pe.sections)

    try:
        sus_functions = sum(
            len([fn for fn in ent.imports if fn.name.decode('utf-8') in sus_examples])
            for ent in pe.DIRECTORY_ENTRY_IMPORT
        )
        features['SuspiciousImportFunctions'] = sus_functions
    except AttributeError:
        features['SuspiciousImportFunctions'] = 0

    num_packers = 0
    try:
        for ent in pe.sections:
            try:
                ent.Name.decode('utf-8')
            except Exception:
                num_packers += 1
    except AttributeError:
        features['SuspiciousNameSection'] = 0

    features['NumberOfPackers'] = num_packers

    try:
        features['SectionsLength'] = len(pe.sections)
    except (ValueError, TypeError):
        features['SectionsLength'] = 0

    try:
        features['SectionMaxEntropy'] = max(entropy)
    except (ValueError, TypeError):
        features['SectionMaxEntropy'] = 0

    try:
        features['SectionMinEntropy'] = min(entropy)
    except (ValueError, TypeError):
        features['SectionMinEntropy'] = 0

    try:
        features['SectionMaxRawsize'] = max(raw_size)
    except (ValueError, TypeError):
        features['SectionMaxRawsize'] = 0

    try:
        features['SectionMinRawsize'] = min(raw_size)
    except (ValueError, TypeError):
        features['SectionMinRawsize'] = 0

    try:
        features['SectionMinVirtualsize'] = min(v_size)
    except (ValueError, TypeError):
        features['SectionMinVirtualsize'] = 0

    try:
        features['SectionMaxVirtualsize'] = max(v_size)
    except (ValueError, TypeError):
        features['SectionMaxVirtualsize'] = 0

    try:
        features['SectionMinPhysical'] = min(phys)
    except (ValueError, TypeError):
        features['SectionMinPhysical'] = 0

    try:
        features['SectionMaxPhysical'] = max(phys)
    except (ValueError, TypeError):
        features['SectionMaxPhysical'] = 0

    try:
        features['SectionMaxVirtual'] = max(v_address)
    except (ValueError, TypeError):
        features['SectionMaxVirtual'] = 0

    try:
        features['SectionMinVirtual'] = min(v_address)
    except (ValueError, TypeError):
        features['SectionMinVirtual'] = 0

    try:
        features['SectionMaxPointerData'] = max(pointer_data)
    except (ValueError, TypeError):
        features['SectionMaxPointerData'] = 0

    try:
        features['SectionMinPointerData'] = min(pointer_data)
    except (ValueError, TypeError):
        features['SectionMinPointerData'] = 0

    try:
        features['SectionMinChar'] = min(characteristics)
    except (ValueError, TypeError):
        features['SectionMinChar'] = 0

    try:
        features['SectionMaxChar'] = max(characteristics)
    except (ValueError, TypeError):
        features['SectionMaxChar'] = 0

    try:
        features['DirectoryEntryImport'] = (len(pe.DIRECTORY_ENTRY_IMPORT))
        entry_imports = sum([x.imports for x in pe.DIRECTORY_ENTRY_IMPORT], [])
        features['DirectoryEntryImportSize'] = (len(entry_imports))
    except AttributeError:
        features['DirectoryEntryImport'] = 0
        features['DirectoryEntryImportSize'] = 0

    try:
        features['DirectoryEntryExport'] = (len(pe.DIRECTORY_ENTRY_EXPORT.symbols))
    except AttributeError:
        features['DirectoryEntryExport'] = 0

    features['ImageDirectoryEntryImport'] = pe.OPTIONAL_HEADER.DATA_DIRECTORY[
        pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_IMPORT']].VirtualAddress

    features['ImageDirectoryEntryExport'] = pe.OPTIONAL_HEADER.DATA_DIRECTORY[
        pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_EXPORT']].VirtualAddress

    features['ImageDirectoryEntryResource'] = pe.OPTIONAL_HEADER.DATA_DIRECTORY[
        pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_RESOURCE']].VirtualAddress

    features['ImageDirectoryEntryException'] = pe.OPTIONAL_HEADER.DATA_DIRECTORY[
        pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_EXCEPTION']].VirtualAddress

    features['ImageDirectoryEntrySecurity'] = pe.OPTIONAL_HEADER.DATA_DIRECTORY[
        pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_SECURITY']].VirtualAddress

    # >>> list of features taken from application put into array <<<
    features_arr = np.array(list(features.values())).reshape(1, -1)

    # >>> Prediction <<<
    data_predict = model.predict(features_arr)

    # >>> Results on if chosen file is Malware or Benign <<<
    result = 'Malware' if np.any(data_predict >= 1) else 'Benign'
    tk.messagebox.showinfo('File Classification',
                           f'The file {filepath} is {result}.')

    print(data_predict)

    return features_arr


# >>> Label to show chosen file path <<<
path_label = tk.Label(root, text="")
path_label.pack()

# >>> Button to open window to input file <<<
open_btn = tk.Button(root, text='Open File', command=open)
open_btn.pack(pady=10)

# >>> Button to run the prediction <<<
run_btn = tk.Button(root, text='Run', command=predict_file)
run_btn.pack(pady=10)

root.mainloop()
